# 2017-08-01

## Basic Ideas

The most basic idea is to provide a flexible platform where AIs can duke it out in a hopefully fair setting.

Really, things don't have to be just limited to arena combat. There could be races, cooperative exploration, resource gathering and so on. 

The core design principle is that the humans in the loop are not so much *players* as they are *coaches*. Once the game begins, they have relatively little involvement.

### Business Model?

If there is a business model lurking in the background, then it is this: 

> Coding is easy. It's Art that's hard.

Make the action free. Sell the pretty.

### Making it Fair

At least for starters, I like the basic RoboWar idea of having programs developed for a specific *Virtual Machine*. So you can spend points on how you want the VM configured (how many threads can it handle? how much memory does it have? and so on...), but everyone has the same points to spend. 

And everyone is getting the same clock ticks.

I also like RoboWar's *interrupt driven* architecture, though here we might make it a little higher level and have it be more "event driven". Ultimately I guess it's the same.

### Architecture

So what do our player-coaches actually see?

If there was a tournament setup, then presumably we'd be dealing with an off-line situation where players submit their AAAIs (Armed and Armored AIs), the tournament is run at a certain set time, and (a) results are published and (b) you can download the log and replay it locally.

But most people are going to want to just write something and turn it loose, to see how it does.
Meaning there would have to be some NPC A3Is that you could load along with your own one.

Also there could be limited interaction. For example, a set of 10 *signals* that can be sent from bench to arena. It would be up to the programmer to decide what each signal meant. I imagine clever programmers would try to arrange to send streams of signals, to increase the amount of information in the channel.
That doesn't work in an offline tournament setting, but with enough players, it could happen that they would find real-time tournament-style scenarios to join.

It could be huge fun if the programmer could type strings at its bot. People could play with language understanding. 
And I suppose it would introduce its own self-limiting tradeoffs: your bot could spend most of its time processing your messages, and not enough time processing its environment and acting in it.

All of this is dancing around the question of: 

> Is there a server?

Or more than one? I guess for tournaments there kind of has to be (unless I can figure out some sort of peer-to-peer way to manage it). But there should be ways to play off line as well. 
I don't think the computational demands are really that strenuous. So pure client-side JavaScript should be able to carry the load.


## Weapons and Armor

Keep it simple. The simplest possible set would consist of a *ranged* weapon, and a *melee* weapon.

A second dimension could be introduced by distinguishing *physical* weapons from *energy* weapons. Basically taking the place of spells...

Corresponding to each type would be specialized defenses. *Armor* would be strong against physical attacks but weak against energy attacks. Whereas *force shields* would be strong against energy attacks, but weak against physical attacks.

There's at least one other *attack medium* that could be explored, namely *psychological* attacks. Defense here would be based on training rather than equipment.

Again, the idea is that in all media there would be a melee versus ranged distinction.


# 2017-08-03

## Walls (Maps, Really)

If movement is continuous in all directions, then walls have to be treated as *objects* and arbitrary collision detection has to be used.

It might be good if walls were made of small discrete segments, so each wall is actually a collection of objects. It seems like this would make collision detection simpler.

Walls would have to have thicknesses, I suppose, unless we imagine that they are just force fields.

Speaking of which, remaining in collision with a wall should do damage. Should it be physical or energy damage?


# 2017-08-05

## Start

A game session consists of a collection of player bots running around an arena until some predefined end-condition is met.
A typical example would be *last bot standing*: once there is only one bot left, the game is over. 
But it could be *flag captured*, or simply *finish line crossed*.

For any of this to happen, we have to know before the start of the game who is playing.

1. That could be defined beforehand in some sort of *tournament roster*.
2. Or it could be defined via a per-player *add*/*remove* menu option.

Also, if there are any non-player game entities (power-ups, collectibles, non-player or hostile bots, manipulable map elements like doors, ramps, etc.), they need to be loaded. Some of them may be assigned fixed map positions, some may be randomly scattered.

The *map* defines a fixed size surface, and positions of any objects that start in a fixed location. This would include things like *wall segments*. Even walls may change during the game, if for example we allow cannons to knock down walls. So a wall segment is just an immobile "character", with hit points, resistances, and no dialog.

If you have a list of randomly distributed items, you can generate their positions first. After that they are just like any other items on the map.

In some cases there could be aspects like *terrain* that are really built in to the map. They aren't really objects with a volume and a pin point.


# 2017-08-09

## Start (cont'd)

There pretty much has to be a server. That's the only way you can load bot files from disk. I don't think there's any way you can load them from disk directly into the browser...

Not so! Here's an example from Stack Overflow
(`https://stackoverflow.com/questions/3582671/how-to-open-a-local-disk-file-with-javascript`):

```
function readSingleFile(e) {
  var file = e.target.files[0];
  if (!file) {
    return;
  }
  var reader = new FileReader();
  reader.onload = function(e) {
    var contents = e.target.result;
    displayContents(contents);
  };
  reader.readAsText(file);
}

function displayContents(contents) {
  var element = document.getElementById('file-content');
  element.textContent = contents;
}

document.getElementById('file-input')
  .addEventListener('change', readSingleFile, false);
```

So that suggests that the whole thing *could* be implemented client-side, at least in theory.

If there *is* a server, 
then the main thing is to establish an interface.
Right now, it's pretty simple:

* Create, read, delete, or update a new Bot resource in the "Bots" collection.
* Display and maybe also clear the entire "Bots" collection.
* Start a game with the current Bots collection.

Also I suppose other game control functions, like *Pause*, *Abort*.
Also there should be a **log**, and functions to view it, replay it, and do other stuff as well.

## About that Log

Really, the sole task of the engine itself is to produce an **event log**.
Other game services will be listening for changes to that log, and doing things like updating the visible game world accordingly.

The engine responds to events like *start*, *pause*, and *abort*.
That's pretty much the only input it accepts.

It also needs to know the collection of bot programs it is running.
Some of those will be players, but there will probably also someday be non-player autonomous agents. (There could be non-agent stuff that moves as well, even it it's just shrapnel, for example.)


# 2017-08-11

## Log Player

It will be crucial to have a log player that people can use. Presumably tournaments would be run off line, and anyone wishing to see what happened would need to be able to replay the log.

Even if they were run on line, so people could spectate in real time, players past and future will very much want to be able to study what happened. So a log player is crucial.

Given the design, where the engine is only responsible for producing a log, the player will probably begin life as a stand-alone service, so this shouldn't be a problem.

## Client-Server

So long-term there has to be a server, because players from all over should be able to submit their bots to a tournament easily.

The development environment will thus probably require a (local) server, even though a lot could probably run in-browser. 
I guess I should consider using `node` for this.


# 2017-08-14

## First Iteration

What gets done first?

The **player pool** can be populated with some always-available sample bots.
I'll need that for testing anyway. 
This in turn suggests that there might be several different *types of player pool*, depending on whether they are:

* included with the game
* developed locally by a player
* registered over the network

So there needs to be an API.
Basically I guess that means there is a **Player Registration Service** in the middleware somewhere. I don't really know how *in-process services* work in JavaScript. WebWorkers, I guess.

1. Someone sends a message, and the worker picks up on it via an event handler.
   A callback, in other words.
2. I suppose any main process could send the message. It could be a test harness,
   governing a fixed set of included bots, or it could be a web server handling HTTP requests, for example.
3. In particular, there is a notion of *shared worker* that might allow multiple
   simultaneous ways of assembling a tournament roster from a collection of player pools.

I guess in general if you want all your services in-process, then you need an App object with members to hold all the services' worker handles.

### Test Mode

The idea is that we start the app in "test mode", which should just give us the default bot pool. I guess that's just a question of navigating to a URL that includes a special path component or query parameter value.

Otherwise, the initial view is roughly what we expect will always be the case: you see a list of available bots, and you can pick which ones you want to load into a single game or tournament.


# 2017-08-15

## Using a Framework

It would make a huge amount of sense to do this, with the proviso that running a server locally should always be easy. In particular, you shouldn't need to compile anything. So the big heavyweight servers are out, and writing something in C++ is out. Maybe Java is okay. But mainly it seems like we're back to node. But even that requires installing node, including v8 and all that stuff.

Right now I'm really leaning towards using *Elm*, which is really a framework masquerading as a whole programming language. It gives some nice functional stuff, and you still end up with HTML and JavaScript.

## Models

Following RoboWar, there's really a few main widgets that we need to be able to display (not necessarily all at once):

1. Arena
2. Debugger
3. Bot Pools and Rosters

The arena would include some kind of *status display*, listing the current set of player bots, and their condition.

There is no plan to include a *code editor*, since any text editor can be used (and should be used). But a *source level debugger* would be nice to have, so you can step through a battle.

Unlike RoboWar, at least some modes of play should support *teams* of bots (actually there was some rudimentary support for teams in RW, but it was not much used). In fact, many scenarios would be expected to pit teams against a fixed dungeon filled with *non-player bots*. There could even be tournaments to see which teams fared the best over a number of runs.

That's mainly an issue for the pools and roster parts of the game model.

1. What bots are registered as available (the pool)
2. What bots are selected for the current run (the players)
3. Clock count (just ticks, no chronons)
4. Bot state: 
    1. program counter
    2. register contents
    3. memory
    4. armor, energy, etc. status
5. World state:
    1. Undestroyed wall segments
    2. Uncollected power-ups
    3. That kind of thing

I guess actually things like wall segments and treasures count as "bots" too. 
Every "playing piece" that can have attributes and state gets to be an individual in some long list of individuals (aka "things we have to draw all the time").

So the core of the model is a collection of *playing pieces*.
It may be divided up into various sub-lists. 
For example, we probably want to distinguish *mobile pieces* from *immobile pieces*, so we don't accidentally move a wall or anything like that.


# 2017-08-18

## Energy

So based on RW, bots will have a certain amount of energy to use, and it will replenish itself over time. 

Unlike RW, if energy drops below zero, the bot's processor will shut down, but it will not stop. It will coast (with zero friction, for now), and take whatever collision damage that entails. So deep energy debts are probably a bad idea, at least if you are in motion.

There should probably be a *back on-line* interrupt.

## Interrupts

More than ever, an interrupt-driven bot programming language makes sense.
Event-driven/"reactive" programming is becoming a big thing, so we can expect some familiarity with it, and it makes it more palatable to learn.

So maybe we even call them "events" rather than "interrupts"?
Or maybe we just say "Certain events can trigger interrupts in your program!"
Because it is true that our events are quite intrusive, rather than just logging themselves into a queue.

Can we have user-defined interrupts? I guess it depends on the complexity of the interrupt trigger...

## Events

It would be possible to treat interrupts as events if we batched different interrupts into different priorities, and had bots scan for events in priority order. 

The main point is that a high-priority interrupt has to take presence over a simultaneous low-priority interrupt.

> When is it possible to interrupt an interrupt handler?
  I guess in RW you could explicitly turn interrupts back on in a handler (I think there were turned off by default). So it's a "use your judgement" kind of thing. But INTOFF is a sensible default behavior for an interrupt handler.


# 2017-08-22

## Synchronizing the Game Loop and the Interpreter

The interpreter is responsible for updating all bot programs in parallel.
So there must be some kind of clock, and on every tick, bots that are eligible to execute on that tick get to advance one instruction.

> If we have different CPU speeds (e.g. 50 instructions per chronon, 30, 15, 
  and 10), then we need something like 150 ticks per chronon, with 50 speed CPUs eligible to execute every third tick, etc.

So there's a notion of *chronon*, which tells us how to synchronize CPUs of different speeds.

The *game loop* is responsible for updating the *view* sixty times per second. 
So it basically reads the *model* and draws sprites according to what the model says their X and Y coordinates are now. For some value of "now".

Obviously, we cannot use the game loop's calls to `update` to run our programs.
Or we could, but we'd have to figure out how many ticks we could consume per frame.

But if the interpreter loop is completely divorced from the game loop, 
then wouldn't a faster machine run the bots faster, thereby making a particular game non-repeatable?

> I don't think so. 
  I think bots might move faster across the screen, but when they shoot, and how far they move in a single chronon is up to the interpreter, no?

Okay, let's examine that phrase "how far they more in a single chronon".
What is movement? Each bot has a `SpeedX` and `SpeedY` register that can change with time. Movement happens by applying *dX* and *dY* to the bot's position, periodically. Speed is "distance per time unit", and we need to update the bot's position every time unit, or multiply the values by number of elapsed time units. Either way, we have to know when time units elapse in order to update the model.

So the key question becomes: *When do we update the actual X and Y positions of our objects?*

### Model, View, Controller

In terms of MVC, the interpreter is our main controller. 
(There's also interface elements, like a Pause button and so on, but these events are infrequent.)

I suppose we could say *Update sprite positions every chronon*.
Then the view updater would have to know how many chronons had elapsed since the last frame.
Well, it wouldn't really. It would just have to read the current X and Y attributes.

> That means that you can update `SpeedX` more than once during a chronon,
  but only the last setting will matter. There's no attempt to figure out how long you spent travelling at speed 1, plus how long you spent travelling at speed 2, etc.

I suppose every time you change a speed register you could update position based on fractional chronons. Speed is distance per tick, in other words.

So, anyway, it is the interpreter's job to keep the model up to date based on program effects. That includes calculating X and Y positions.
And I suppose you actually could store speed as distance per tick, rather than distance per chronon. 

Note, however, that any time position changes, there's a whole host of events that may be triggered. You could suddenly enter into a collision. So now collision detection has to happen 150 times per chronon.
Plus there's sighting: someone might collide with someone else's aim or range lines.
And then after collision with a projectile, we have to check to see if a bot's health alert has been triggered (not to mention if it's dead).
In fact, after any loss of HP (e.g., due to collision with any other kind of object).

If you reject sub-frame or sub-chronon changes of velocity and just focus on generating smooth frames, then I suppose a lot of problems become simpler.

The thing is that in normal games there is a sort of external thread pool running in the player's head, so the control threads are not running under game control. In this game, each bot is a "player", and we have to internalize the player's head as a game world process. So that's why there may be an extra layer of synchronization that we have to deal with.

Maybe the best way to do this is to really simulate a bunch of players playing a game, as if the bot programs themselves could mash buttons on a controller, which the "inner game" then interprets as normal.

> If a neural net can play a AAA combat game, then the idea of having 
  artificial players can't really demand that much from the engine.
  We just need an API.

### Physics Engine

Suppose we want a physics engine to handle collisions and movement?
The program just updates velocities (and scope manipulation).
Consequences of collisions as they affect velocities would be imposed by the physics engine.
The program would be notified of a collision via an interrupt or event, so it could check its new bounced heading and correct it.

I think in such a case there would be a step in which "user input" is collected and digested, maybe check for damage and destruction, and then a step in which the physics engine does its thing and calculates new positions and velocities for all the mobs. 

### Pulling It All Together

So the point is that any frame-based game is in some sense chronon based. 
Changes in position happen discretely, once per frame update.
Even with a physics engine, stepping only happens once per frame.
Though there is some wiggle room to allow for recalculating positions once a collision is detected.
But crucially a player does not have an opportunity to react to such a bounce until the next frame. 
It doesn't appear to matter, because that's as soon as an observer could possibly have seen the bounce happen. And everything appears to be happening smoothly.
Your frantic button mashing will have an "immediate" effect, i.e., during the updates for the preparation of the next frame.

So there's a basic game in which a bunch of circles move around and bounce off each other and off of walls, whack at each other with short and long ranged weapons, and blow up.
That basic game exposes a bunch of *controllers* that determine when a mob will move, when it will use what attack, what direction it's looking in, and so on.
These controllers *could* be manipulated by a player with a literal game controller in their hands, but in fact they are to be manipulated by *programs*. 

So the key thing is to figure out what behavioral affordances the bots expose, and then have a programming language that can manipulate them.


## What Can You Make Bots Do?

There's three basic areas I can think of right away:

1. Moving
2. Fighting
3. Looking Around

The latter is easy to overlook, since it isn't part of normal games.
But it's important here.

Also there ought to be a possibility for fighting to include movement, 
namely bumping into enemies and knocking them around. 
Possibly doing damage, and certainly manipulating the map.

### Vision

In RW, there were at least two different scopes: one for enemies (aim, look, range, doppler) and one for projectiles (aim, scan, radar). 
I think with a more general event reporting facility, 
it should be possible to pack a lot of this info into the event data.
Like the record could indicate whether it was a bot or a projectile that was spotted, its range, and its doppler value, all in one.
Which in turn would mean that there could be a single scope.
That would be nice for games where the bots were like humanoid adventurers rather than tanks or demolition derby cars.

You should be able to do things like ignore projectiles if you just want to find the enemies.


# 2017-08-23

## Vision (cont'd)

In `Robocode`, it looks like you just tell the bot to rotate its turret however many degrees, and you get an interrupt if it spots anything. 
At that point you can read off pretty much anything there is to know about the thing you spotted.

I think we want to keep things as simple as possible, so as to derive a game that is elegant but hard to master.

Note that specifying a full rotation in one instruction leaves the run-time with a lot to do. Presumably all turret movements have to happen at the same speed, or there is no way to tell who spotted who first. So in that sense a lower level language is better. In practice in RW there's only a few aim loops, and they mostly come out of cans.

Is there any reason to try to implement some sort of *peripheral vision*?
So there's an *aim angle*, which governs where shots will go, 
and then there's an arc within which objects will trigger interrupts.
RW has something like this: I think scanning works with an arc of 40 degrees or so.

You would have to be able to re-aim at an enemy spotted off of the aim line, so the angle to that object would have to be part of the event report.

Then there's the infamous *frame problem*: You spot something, you handle it, you return to your aim loop, and it's still there in your Field of Vision. 
Does it trigger an interrupt again? Does your bot become obsessed with everything it sees?
Or do we somehow only trigger interrupts on new information?

## Buffs and Debuffs

There probably needs to be some support for this. 
Maybe just a boost in weapons power or shield strength? 
Hit points, movement speed, maybe even CPU speed?


# 2017-08-28

## Events, Cont'd

Actually, any event based system has the same problem. 
Events should really be restricted to change of state.
So "mouse enters/leaves region" rather than "mouse in region".

Given that, it's pretty clear that "enemy in sight" is not an event.
But then we'd have to do something like check all location updates against all fields of view to see if they enter any new ones.

One nice thing about RW's aim system is that events are triggered by the movement of the turret, not the other bots. I think.
That is, only when you pump a value into the `AIM` register will an interrupt be triggered. 
Still not totally positive about that though.

Or, everything could be updated every frame,
so every entity always has a list of things that it can see as of the start of the update cycle.
So, sort of:

1. Move
2. Update *visible objects* lists
3. React

So phase 1 and 2 happen in between bot update stages.

That makes it sound like the world and the bot brain are not just running freely in parallel, but rather *take turns* getting the game engine's attention.

Here's the thing: Objects in the game world are not in continuous motion. 
They hop from point to point on frame updates.
Otherwise you waste tons of time updating positions in tiny fractions,
without materially increasing player enjoyment.

*Head movement* is the other thing that changes what objects are visible.
So both object movement (phase 1) and head movement (phase 3, updates to focus direction) can lead to "new object perceived" events.

### When in doubt, just port RoboWar

It's important to have something that works, as soon as possible.
So what would that be, at a bare minimum?

In RW, the `RANGE` and `RADAR` interrupts are used, and they are triggered either (a) at the start of a chronon, or (b) when the `AIM` register changes (or the auxiliary `LOOK` and `SCAN` registers).
Note that they can be parameterized to have a maximum distance that we care about. So we can be myopic if we want to be.

In a MVP, we can skip the look and scan registers.


## Initial Positions

Problem: Given a list of *n* bots, distribute them randomly in a *n x n* grid so that, for any given bot, no other bot is in its row or column.

One way would be to generate two lists of integers, of length *n*, each randomly shuffled, and then zip them.
That way each row and column can only be used once.


# 2017-08-29

## Frames, Chronons, Ticks

I suppose it would be possible to try to have *one tick per frame*.
Most bots would not be doing anything that frame, in that case.
So could we keep up?

Not sure what we would gain. I suppose if `SpeedX` and `SpeedY` are in pixels per chronon, then on every tick you would move one 150th of that, which is probably just a small fraction of a pixel.

Suppose we have CPU speeds of 50, 30, and 15 instructions per chronon.
That's one instruction per 3, 5, and 10 ticks.
I guess that means every 30 ticks all bots get to execute.
So I suppose we could divide the chronon up into 5 groups of 30 ticks, and try to do a frame per tick-group.

The main point has to do with *what a bot sees*. 
In the simplest case there is a model of how things were at the last chronon break, and that's what a bot sees.

That means that a bot should not be allowed to do anything that alters the model in between chronon breaks. So jumps, shots, and so on, can only happen at chronon breaks.

There is a complication with *collision detection*.
It is possible for a bot to be moving so fast, that a projectile that should have hit it will miss it because it appears to hop from its last position to its next position, without occupying any of the pixels in between.

Here's where I'd really like to have someone else's physics engine deal with collisions.

## Update Function

Maybe this can be done in two parts:

1. Run the interpreter for one chronon
2. Update positions based on final dx, dy
   (and queue interrupts?)

Some interrupts will happen during execution, because of moving the AIM.
But most of them will happen as a consequence of movement, and movement happens on chronon breaks.

I'm looking at examples to see how they handle player input, and it looks like they do not interrupt execution but rather record the event for inspection during `update()`. Well, based on a sample of size 1...
Okay, 2. That's a quorum!

## Programs

Let's start with a really simple aim loop. Something like:

```
aim := aim + 5
```

If we allow instruction counting, then we have to know in some detail the operational semantics of something like this. 
Compare:

```
aim ADD 5
```

This assumes `aim` really has register-like qualities, so we don't have to do something like:

```
LOAD A, aim
ADD A, 5
STORE aim, A
```

So the whole loop might look like:
```
Loop_1:
  aim ADD 5
  JUMP Loop_1
```

Movement is also just register storage and arithmetic:
```
  dx STORE 1
  dy ADD -2
```

### Walls, and Maps

Once agents can move, they are going to move right off the map.
So we need walls, and we need some way of knowing when you have hit a wall.

So we need some sort of *map* representation.
This is going to change a lot before it's done, 
so it doesn't probably matter whether I get it right the first time...

# 2017-08-30

## Drive, Bounce, and Direction

It seems like a lot of physics engines just assume objects *drift*.
They have some initial impulse, but after that they just bounce around like billiard balls.
An agent, on the other hand, has some internally generated *drive*: a motor, or pumping leg muscles.
Importantly, until there is an actual response by the program to a collision, that drive vector doesn't change.
In other words, if we run straight into a wall, we continue pushing against it even after we bounce.

Most importantly, I think that means that *dx* and *dy* cannot be program writable. They are now *computed values* that presumably combine bounce and drive. So that, barring programmatic reactions, we hit the wall, bounce, and run into it again. Presumably at some point we stop bouncing, and just push.

Then there's the effect of *friction*, and a question of how exactly our motors work. If there is no friction, then we don't continually apply force in a given direction; we generate an impulse, and then coast.
In that case, bouncing helplessly does make sense. 
We then just apply a new impulse in our collision response routines.

In RW, only changes in direction cost energy.
So the floor of the arena is basically frictionless, in that sense.
Although there is no *momentum* at all, so you don't have to counteract your current direction. There's no *swerve* around corners, in other words.


# 2017-08-31

## Drive, Cont'd

Using `matter.js`, it is possible to set a body's velocity directly,
but it seems like we would get better simulations if we used *impulses* to drive the bots.

We're basically playing **Roombas on Ice**, with no friction.
So it's not necessary to continually expend energy on drive.
Instead, it's like firing *retro rockets* in space.

To make this work, I think I need to figure out some kind of *unit impulse*,
which involves tuning bodies' densities (and hence their mass), as well as the force applied to them.

The goal is to allow the player to drive with as few instructions as possible.
Ideally it would be as simple as:
```
setDrive (angle, speed)
```
Then it would be up to the game engine to figure out what that meant in terms of a force vector to apply.

Maybe also allow `setDrive (x, y, speed)`, where we would scale *[x,y]* to length one, and then scale it by *speed*.
So you would be basically saying things like "Head towards the northeast corner very fast," and like that.
Though in that case you are supplying a target destination, the vector for which would vary with the bot's position...

So there might be like 3 instructions:

* `driveAngle`
* `driveVector`
* `drivePoint`

It might also be the case that setting the drive direction could be a separate instruction from setting the drive force, since we might want to vary them independently.

## Sprite Decorations

I want to decorate player sprites with both a visible label and a health bar.
The label is already implemented, but it can get covered up by another sprite in a collision.
So I think decorations should be drawn on another "layer".
That is, draw all the sprites first, then draw the label and the health bar afterwards.
This requires two passes through the sprite list, I guess, but it's a short list.
As long as we keep the player list separate from the others, that is!

